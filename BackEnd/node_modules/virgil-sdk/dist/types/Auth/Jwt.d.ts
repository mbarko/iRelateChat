import { IExtraData } from '../Cards/ICard';
import { IAccessToken, ITokenContext } from './AccessTokenProviders/index';
/**
 * The callback function used to get the JWT as either `string`, or {@Link Jwt} instance
 * synchronously or asynchronously.
 */
export declare type GetJwtCallback = (context: ITokenContext) => Promise<Jwt | string> | Jwt | string;
/**
 * Interface for objects representing JWT Header.
 */
export interface IJwtHeader {
    /**
     * The algorithm used to calculate the token signature.
     */
    readonly alg: string;
    /**
     * The type of the token. Always "JWT".
     */
    readonly typ: string;
    /**
     * The content type of the token.
     */
    readonly cty: string;
    /**
     * Id of the API Key used to calculate the token signature.
     */
    readonly kid: string;
}
/**
 * Interface for objects representing JWT Body.
 */
export interface IJwtBody {
    /**
     * The issuer of the token (i.e. Application ID)
     */
    readonly iss: string;
    /**
     * The subject of the token (i.e. User identity)
     */
    readonly sub: string;
    /**
     * The token issue date as Unix timestamp
     */
    readonly iat: number;
    /**
     * The token expiry date as Unix timestamp
     */
    readonly exp: number;
    /**
     * User-defined attributes associated with the token
     */
    readonly ada?: IExtraData;
}
/**
 * Class representing the JWT providing access to the
 * Virgil Security APIs.
 * Implements {@link IAccessToken} interface.
 */
export declare class Jwt implements IAccessToken {
    /**
     * Parses the string representation of the JWT into
     * an object representation.
     *
     * @param {string} jwtStr - The JWT string. Must have the following format:
     *
     * `base64UrlEncode(Header) + "." + base64UrlEncode(Body) + "." + base64UrlEncode(Signature)`
     *
     * See the {@link https://jwt.io/introduction/ | Introduction to JWT} for more details.
     *
     * @returns {Jwt}
     */
    static fromString(jwtStr: string): Jwt;
    readonly header: IJwtHeader;
    readonly body: IJwtBody;
    readonly signature?: string;
    /**
     * The data used to calculate the JWT Signature
     *
     * `base64UrlEncode(header) + "." + base64UrlEncode(body)`
     */
    readonly unsignedData: string;
    private readonly stringRepresentation;
    /**
     * Creates a new instance of `Jwt` from the given string. The string
     * must be in the following format:
     * `base64UrlEncode(header).base64UrlEncode(body).base64UrlEncode(signature)`
     * @param {string} stringRepresentation
     */
    constructor(stringRepresentation: string);
    /**
     * Creates a new instance of `Jwt` with the given header, body and
     * optional signature.
     *
     * @param {IJwtHeader} header
     * @param {IJwtBody} body
     * @param {string} signature
     */
    constructor(header: IJwtHeader, body: IJwtBody, signature?: string);
    /**
     * Returns the string representation of this JWT.
     * @returns {string}
     */
    toString(): string;
    /**
     * Retrieves the identity that is the subject of this JWT.
     * @returns {string}
     */
    identity(): string;
    /**
     * Retrieves the application ID that is the issuer of this JWT.
     * @returns {string}
     */
    appId(): string;
    /**
     * Returns a boolean indicating whether this JWT is (or will be)
     * expired at the given date or not.
     *
     * @param {Date} at - The date to check. Defaults to `new Date()`.
     * @returns {boolean} - `true` if token is expired, otherwise `false`.
     */
    isExpired(at?: Date): boolean;
    private headerBase64;
    private bodyBase64;
    private signatureBase64;
}
