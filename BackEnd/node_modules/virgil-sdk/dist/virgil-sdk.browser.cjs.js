'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var base64 = createCommonjsModule(function (module, exports) {
(function(root) {

	// Detect free variables `exports`.
	var freeExports =  exports;

	// Detect free variable `module`.
	var freeModule =  module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code, and use
	// it as `root`.
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var InvalidCharacterError = function(message) {
		this.message = message;
	};
	InvalidCharacterError.prototype = new Error;
	InvalidCharacterError.prototype.name = 'InvalidCharacterError';

	var error = function(message) {
		// Note: the error messages used throughout this file match those used by
		// the native `atob`/`btoa` implementation in Chromium.
		throw new InvalidCharacterError(message);
	};

	var TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	// http://whatwg.org/html/common-microsyntaxes.html#space-character
	var REGEX_SPACE_CHARACTERS = /[\t\n\f\r ]/g;

	// `decode` is designed to be fully compatible with `atob` as described in the
	// HTML Standard. http://whatwg.org/html/webappapis.html#dom-windowbase64-atob
	// The optimized base64-decoding algorithm used is based on @atk’s excellent
	// implementation. https://gist.github.com/atk/1020396
	var decode = function(input) {
		input = String(input)
			.replace(REGEX_SPACE_CHARACTERS, '');
		var length = input.length;
		if (length % 4 == 0) {
			input = input.replace(/==?$/, '');
			length = input.length;
		}
		if (
			length % 4 == 1 ||
			// http://whatwg.org/C#alphanumeric-ascii-characters
			/[^+a-zA-Z0-9/]/.test(input)
		) {
			error(
				'Invalid character: the string to be decoded is not correctly encoded.'
			);
		}
		var bitCounter = 0;
		var bitStorage;
		var buffer;
		var output = '';
		var position = -1;
		while (++position < length) {
			buffer = TABLE.indexOf(input.charAt(position));
			bitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer;
			// Unless this is the first of a group of 4 characters…
			if (bitCounter++ % 4) {
				// …convert the first 8 bits to a single ASCII character.
				output += String.fromCharCode(
					0xFF & bitStorage >> (-2 * bitCounter & 6)
				);
			}
		}
		return output;
	};

	// `encode` is designed to be fully compatible with `btoa` as described in the
	// HTML Standard: http://whatwg.org/html/webappapis.html#dom-windowbase64-btoa
	var encode = function(input) {
		input = String(input);
		if (/[^\0-\xFF]/.test(input)) {
			// Note: no need to special-case astral symbols here, as surrogates are
			// matched, and the input is supposed to only contain ASCII anyway.
			error(
				'The string to be encoded contains characters outside of the ' +
				'Latin1 range.'
			);
		}
		var padding = input.length % 3;
		var output = '';
		var position = -1;
		var a;
		var b;
		var c;
		var buffer;
		// Make sure any padding is handled outside of the loop.
		var length = input.length - padding;

		while (++position < length) {
			// Read three bytes, i.e. 24 bits.
			a = input.charCodeAt(position) << 16;
			b = input.charCodeAt(++position) << 8;
			c = input.charCodeAt(++position);
			buffer = a + b + c;
			// Turn the 24 bits into four chunks of 6 bits each, and append the
			// matching character for each of them to the output.
			output += (
				TABLE.charAt(buffer >> 18 & 0x3F) +
				TABLE.charAt(buffer >> 12 & 0x3F) +
				TABLE.charAt(buffer >> 6 & 0x3F) +
				TABLE.charAt(buffer & 0x3F)
			);
		}

		if (padding == 2) {
			a = input.charCodeAt(position) << 8;
			b = input.charCodeAt(++position);
			buffer = a + b;
			output += (
				TABLE.charAt(buffer >> 10) +
				TABLE.charAt((buffer >> 4) & 0x3F) +
				TABLE.charAt((buffer << 2) & 0x3F) +
				'='
			);
		} else if (padding == 1) {
			buffer = input.charCodeAt(position);
			output += (
				TABLE.charAt(buffer >> 2) +
				TABLE.charAt((buffer << 4) & 0x3F) +
				'=='
			);
		}

		return output;
	};

	var base64 = {
		'encode': encode,
		'decode': decode,
		'version': '0.1.0'
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = base64;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (var key in base64) {
				base64.hasOwnProperty(key) && (freeExports[key] = base64[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.base64 = base64;
	}

}(commonjsGlobal));
});

/**
 * Decodes the base64 encoded string into a `string`.
 * @hidden
 * @param {string} input
 * @returns {string}
 */
function base64Decode(input) {
    return base64.decode(input);
}
/**
 * Encodes the `input` string into a base64 `string`.
 * @hidden
 * @param {string} input
 * @returns {string}
 */
function base64Encode(input) {
    return base64.encode(input);
}
/**
 * Converts regular base64 encoded string to URL-safe base64 encoded string.
 * @hidden
 * @param {string} input - Regular base64 encoded string.
 * @returns {string} - URL-safe base64 encoded string.
 */
function base64UrlFromBase64(input) {
    input = input.split('=')[0];
    input = input.replace(/\+/g, '-').replace(/\//g, '_');
    return input;
}
/**
 * Converts URL-safe base64 encoded string to regular base64 encoded string.
 * @hidden
 * @param {string} input - URL-safe base64 encoded string.
 * @returns {string} - Regular base64 encoded string.
 */
function base64UrlToBase64(input) {
    input = input.replace(/-/g, '+').replace(/_/g, '/');
    switch (input.length % 4) {
        case 0: break; // no padding needed
        case 2:
            input = input + '==';
            break;
        case 3:
            input = input + '=';
            break;
        default:
            throw new Error('Invalid base64 string');
    }
    return input;
}
/**
 * * Encodes the `input` string into a string using URL-safe base64 encoding.
 *
 * @hidden
 *
 * @param {string} input - The input.
 * @returns {string}
 */
function base64UrlEncode(input) {
    var output = base64Encode(input);
    return base64UrlFromBase64(output);
}
/**
 * Decodes the URL-safe base64-encoded `input` string into a `string`.
 *
 * @hidden
 *
 * @param {string} input
 * @returns {string}
 */
function base64UrlDecode(input) {
    var str = base64UrlToBase64(input);
    return base64Decode(str);
}

/**
 * Converts javascript date object or timestamp in milliseconds
 * to Unix timestamp.
 *
 * @hidden
 *
 * @param {Date | number} date - The date or timestamp to convert.
 * @returns {number}
 */
function getUnixTimestamp(date) {
    var time;
    if (typeof date === 'number') {
        time = date;
    }
    else {
        time = date.getTime();
    }
    return Math.floor(time / 1000);
}
/**
 * Adds the given number of seconds to the given date.
 *
 * @hidden
 *
 * @param {Date | number} date - The date to add seconds to.
 * If `date` is a `number` it is treated as a timestamp in milliseconds.
 * @param {number} seconds - The number of seconds to add.
 * @returns {Date} - The new date.
 */
function addSeconds(date, seconds) {
    if (typeof date === 'number') {
        return new Date(date + seconds * 1000);
    }
    return new Date(date.getTime() + seconds * 1000);
}

/**
 * JWT Subject.
 * @hidden
 */
var SubjectPrefix = "identity-";
/**
 * JWT Issuer.
 * @hidden
 */
var IssuerPrefix = "virgil-";
/**
 * Content type of the token. Used to convey structural information
 * about the JWT.
 * @hidden
 */
var VirgilContentType = "virgil-jwt;v=1";
/**
 * Media type of the JWT.
 * @hidden
 */
var JwtContentType = "JWT";

/**
 * Class representing the JWT providing access to the
 * Virgil Security APIs.
 * Implements {@link IAccessToken} interface.
 */
var Jwt = /** @class */ (function () {
    function Jwt(header, body, signature) {
        if (typeof header === 'string') {
            var stringRepresentation = header;
            var parts = stringRepresentation.split('.');
            if (parts.length !== 3)
                throw new Error('Wrong JWT format');
            try {
                this.header = JSON.parse(base64UrlDecode(parts[0]));
                this.body = JSON.parse(base64UrlDecode(parts[1]));
                this.signature = base64UrlToBase64(parts[2]);
            }
            catch (e) {
                throw new Error('Wrong JWT format');
            }
            this.unsignedData = parts[0] + '.' + parts[1];
            this.stringRepresentation = stringRepresentation;
        }
        else if (typeof header === 'object' && typeof body === 'object') {
            this.header = header;
            this.body = body;
            this.signature = signature;
            this.unsignedData = this.headerBase64() + '.' + this.bodyBase64();
            this.stringRepresentation = this.signature == null
                ? this.unsignedData
                : this.unsignedData + '.' + this.signatureBase64();
        }
        else {
            throw new TypeError('Invalid arguments for function Jwt. ' +
                'Expected a string representation of a token, or header and body as objects');
        }
    }
    /**
     * Parses the string representation of the JWT into
     * an object representation.
     *
     * @param {string} jwtStr - The JWT string. Must have the following format:
     *
     * `base64UrlEncode(Header) + "." + base64UrlEncode(Body) + "." + base64UrlEncode(Signature)`
     *
     * See the {@link https://jwt.io/introduction/ | Introduction to JWT} for more details.
     *
     * @returns {Jwt}
     */
    Jwt.fromString = function (jwtStr) {
        return new Jwt(jwtStr);
    };
    /**
     * Returns the string representation of this JWT.
     * @returns {string}
     */
    Jwt.prototype.toString = function () {
        return this.stringRepresentation;
    };
    /**
     * Retrieves the identity that is the subject of this JWT.
     * @returns {string}
     */
    Jwt.prototype.identity = function () {
        if (this.body.sub.indexOf(SubjectPrefix) !== 0) {
            throw new Error('wrong sub format');
        }
        return this.body.sub.substr(SubjectPrefix.length);
    };
    /**
     * Retrieves the application ID that is the issuer of this JWT.
     * @returns {string}
     */
    Jwt.prototype.appId = function () {
        if (this.body.iss.indexOf(IssuerPrefix) !== 0) {
            throw new Error('wrong iss format');
        }
        return this.body.iss.substr(IssuerPrefix.length);
    };
    /**
     * Returns a boolean indicating whether this JWT is (or will be)
     * expired at the given date or not.
     *
     * @param {Date} at - The date to check. Defaults to `new Date()`.
     * @returns {boolean} - `true` if token is expired, otherwise `false`.
     */
    Jwt.prototype.isExpired = function (at) {
        if (at === void 0) { at = new Date; }
        var now = getUnixTimestamp(at);
        return this.body.exp < now;
    };
    Jwt.prototype.headerBase64 = function () {
        return base64UrlEncode(JSON.stringify(this.header));
    };
    Jwt.prototype.bodyBase64 = function () {
        return base64UrlEncode(JSON.stringify(this.body));
    };
    Jwt.prototype.signatureBase64 = function () {
        return base64UrlFromBase64(this.signature);
    };
    return Jwt;
}());

/**
 * Test if `condition` is truthy. If it is not, an `Error` is thrown with a
 * `message` property equal to `message` parameter.
 * @hidden
 * @param {boolean} condition
 * @param {string} message
 */
function assert(condition, message) {
    if (!condition) {
        throw new Error(message);
    }
}

var DEFAULT_TOKEN_TTL = 20 * 60 * 1000; // 20 minutes
/**
 * Class responsible for JWT generation.
 */
var JwtGenerator = /** @class */ (function () {
    function JwtGenerator(options) {
        validateOptions(options);
        this.appId = options.appId;
        this.apiKey = options.apiKey;
        this.apiKeyId = options.apiKeyId;
        this.accessTokenSigner = options.accessTokenSigner;
        this.millisecondsToLive = options.millisecondsToLive !== undefined
            ? Number(options.millisecondsToLive)
            : DEFAULT_TOKEN_TTL;
    }
    /**
     * Generates a token with the given identity as the subject and optional
     * additional data.
     * @param {string} identity - Identity to be associated with JWT (i.e.
     * the Subject).
     * @param {IExtraData} ada - Additional data to be encoded in the JWT.
     * @returns {Jwt}
     */
    JwtGenerator.prototype.generateToken = function (identity, ada) {
        if (!identity) {
            throw new TypeError('Illegal arguments for function `generateToken`. Argument `identity` is required.');
        }
        var iat = getUnixTimestamp(new Date());
        var exp = getUnixTimestamp(new Date().getTime() + this.millisecondsToLive);
        var body = {
            iss: IssuerPrefix + this.appId,
            sub: SubjectPrefix + identity,
            iat: iat,
            exp: exp,
            ada: ada
        };
        var header = {
            alg: this.accessTokenSigner.getAlgorithm(),
            kid: this.apiKeyId,
            typ: JwtContentType,
            cty: VirgilContentType
        };
        var unsignedJwt = new Jwt(header, body);
        var signature = this.accessTokenSigner.generateTokenSignature({ value: unsignedJwt.unsignedData, encoding: 'utf8' }, this.apiKey);
        return new Jwt(header, body, signature.toString('base64'));
    };
    return JwtGenerator;
}());
function validateOptions(opts) {
    var invalidOptionMessage = function (name) {
        return "Invalid JwtGenerator options. `" + name + "` is required";
    };
    assert(opts != null, 'JwtGenerator options must be provided');
    assert(opts.apiKey != null, invalidOptionMessage('apiKey'));
    assert(opts.apiKeyId != null, invalidOptionMessage('apiKeyId'));
    assert(opts.appId != null, invalidOptionMessage('appId'));
    assert(opts.accessTokenSigner != null, invalidOptionMessage('accessTokenSigner'));
}

/**
 * Class responsible for verification of JWTs.
 */
var JwtVerifier = /** @class */ (function () {
    function JwtVerifier(options) {
        validateOptions$1(options);
        this.accessTokenSigner = options.accessTokenSigner;
        this.apiPublicKey = options.apiPublicKey;
        this.apiKeyId = options.apiKeyId;
    }
    /**
     * Verifies the validity of the given JWT.
     * @param {Jwt} token - The JWT to verify.
     * @returns {boolean}
     */
    JwtVerifier.prototype.verifyToken = function (token) {
        if (token == null) {
            throw new Error('Token is empty');
        }
        if (!this.allFieldsAreCorrect(token)) {
            return false;
        }
        return this.accessTokenSigner.verifyTokenSignature({ value: token.unsignedData, encoding: 'utf8' }, { value: token.signature, encoding: 'base64' }, this.apiPublicKey);
    };
    JwtVerifier.prototype.allFieldsAreCorrect = function (token) {
        return token.header.kid == this.apiKeyId
            && token.header.alg == this.accessTokenSigner.getAlgorithm()
            && token.header.cty == VirgilContentType
            && token.header.typ == JwtContentType;
    };
    return JwtVerifier;
}());
function validateOptions$1(opts) {
    var invalidOptionMessage = function (name) {
        return "Invalid JwtVerifier options. `" + name + "` is required";
    };
    assert(opts != null, 'JwtVerifier options must be provided');
    assert(opts.apiPublicKey != null, invalidOptionMessage('apiPublicKey'));
    assert(opts.apiKeyId != null, invalidOptionMessage('apiKeyId'));
    assert(opts.accessTokenSigner != null, invalidOptionMessage('accessTokenSigner'));
}

var TOKEN_EXPIRATION_MARGIN = 5;
/**
 * Implementation of {@link IAccessTokenProvider} that caches the JWT
 * in memory while it's fresh (i.e. not expired) and uses the user-provided
 * callback function to get the JWT when requested by the clients.
 */
var CachingJwtProvider = /** @class */ (function () {
    /**
     * Creates a new instance of `CachingJwtProvider`.
     * @param {GetJwtCallback} renewJwtFn - The function that will be called
     * whenever the fresh JWT is needed. If the `renewJwtFn` returns the JWT
     * as a string, it will be converted to {@link Jwt} instance automatically.
     * @param {Jwt|string} [initialToken] - Optional initial JWT.
     */
    function CachingJwtProvider(renewJwtFn, initialToken) {
        var _this = this;
        if (typeof renewJwtFn !== 'function') {
            throw new TypeError('`renewJwtFn` must be a function');
        }
        if (initialToken) {
            var jwt = void 0;
            if (typeof initialToken === 'string') {
                jwt = Jwt.fromString(initialToken);
            }
            else if (initialToken instanceof Jwt) {
                jwt = initialToken;
            }
            else {
                throw new Error("Expected \"initialToken\" to be a string or an instance of Jwt, got " + typeof initialToken);
            }
            this.cachedJwt = jwt;
        }
        this.getJwt = function (context) {
            if (_this.cachedJwt && !_this.cachedJwt.isExpired(addSeconds(new Date, TOKEN_EXPIRATION_MARGIN))) {
                return Promise.resolve(_this.cachedJwt);
            }
            if (_this.jwtPromise) {
                return _this.jwtPromise;
            }
            _this.jwtPromise = Promise.resolve(renewJwtFn(context))
                .then(function (token) {
                var jwt = typeof token === 'string' ? Jwt.fromString(token) : token;
                _this.cachedJwt = jwt;
                _this.jwtPromise = undefined;
                return jwt;
            }).catch(function (err) {
                _this.jwtPromise = undefined;
                throw err;
            });
            return _this.jwtPromise;
        };
    }
    /**
     * Returns a `Promise` resolved with the cached token if it's fresh, or the
     * token obtained by the call to the `renewJwtCallback` otherwise. The token
     * obtained from the `renewJwtCallback` is then cached. If the `renewJwtCallback`
     * returns the JWT as a string, it is converted to {@link Jwt} instance before returning.
     * @param {ITokenContext} context
     * @returns {Promise<IAccessToken>}
     */
    CachingJwtProvider.prototype.getToken = function (context) {
        return this.getJwt(context);
    };
    return CachingJwtProvider;
}());

/**
 * Implementation of {@link IAccessToken} that calls the user-provided
 * callback function to get the JWT when requested by the clients.
 */
var CallbackJwtProvider = /** @class */ (function () {
    /**
     * Creates a new instance of `CallbackJwtProvider`.
     *
     * @param {GetJwtCallback} getJwtFn - The function that will be called
     * whenever the JWT is needed. If the `getJwtFn` returns the JWT as a
     * string, it will be converted to {@link Jwt} instance automatically.
     */
    function CallbackJwtProvider(getJwtFn) {
        if (typeof getJwtFn !== 'function') {
            throw new TypeError('`getJwtFn` must be a function');
        }
        this.getJwt = function (context) {
            return Promise.resolve(getJwtFn(context))
                .then(function (token) { return typeof token === 'string' ? Jwt.fromString(token) : token; });
        };
    }
    /**
     * Returns a `Promise` resolved with the {@link Jwt} instance obtained
     * by the call to the {@link CallbackJwtProvider.getJwt}. If the
     * `getJwtFn` returns the JWT as a string, it is converted to
     * {@link Jwt} instance before returning.
     *
     * @param {ITokenContext} context
     * @returns {Promise<IAccessToken>}
     */
    CallbackJwtProvider.prototype.getToken = function (context) {
        return this.getJwt(context);
    };
    return CallbackJwtProvider;
}());

/**
 * Implementation of {@link IAccessTokenProvider} that returns a
 * user-provided constant access token whenever it is requested by the clients.
 */
var ConstAccessTokenProvider = /** @class */ (function () {
    /**
     * Creates a new instance of `ConstAccessTokenProvider`
     * @param {IAccessToken} accessToken - The access token to be returned
     * whenever it is requested.
     */
    function ConstAccessTokenProvider(accessToken) {
        this.accessToken = accessToken;
        if (accessToken == null) {
            throw new TypeError('`accessToken` is required');
        }
    }
    /**
     * Returns a `Promise` fulfilled with the
     * {@link ConstAccessTokenProvider.accessToken} provided to the constructor
     * of this instance.
     *
     * @param {ITokenContext} context
     * @returns {Promise<IAccessToken>}
     */
    ConstAccessTokenProvider.prototype.getToken = function (context) {
        return Promise.resolve(this.accessToken);
    };
    return ConstAccessTokenProvider;
}());

/**
 * Implementation of {@link IAccessTokenProvider} that generates a
 * new JWT whenever it is requested by the clients.
 *
 * This class is meant to be used on the server side only.
 */
var GeneratorJwtProvider = /** @class */ (function () {
    /**
     * Creates a new instance of `GeneratorJwtProvider` with the given
     * {@link JwtGenerator}, additional data and default identity.
     *
     * @param {JwtGenerator} jwtGenerator - Object to delegate the JWT generation to.
     * @param {IExtraData} additionalData - Additional data to include with the JWT.
     * @param {string} defaultIdentity - Identity of the user to include in the token
     * when none is provided explicitly by the client.
     */
    function GeneratorJwtProvider(jwtGenerator, additionalData, defaultIdentity) {
        this.jwtGenerator = jwtGenerator;
        this.additionalData = additionalData;
        this.defaultIdentity = defaultIdentity;
        if (jwtGenerator == null) {
            throw new TypeError('`jwtGenerator` is required');
        }
    }
    /**
     * Returns a `Promise` fulfilled with the JWT obtained from the call
     * to {@link GeneratorJwtProvider.jwtGenerator} {@link JwtGenerator.generateToken}
     * method, passing it the {@link GeneratorJwtProvider.additionalData} and
     * {@link GeneratorJwtProvider.defaultIdentity}
     *
     * @param {ITokenContext} context
     * @returns {Promise<IAccessToken>}
     */
    GeneratorJwtProvider.prototype.getToken = function (context) {
        var _this = this;
        return Promise.resolve().then(function () {
            var jwt = _this.jwtGenerator.generateToken(context.identity || _this.defaultIdentity || '', _this.additionalData);
            return jwt;
        });
    };
    return GeneratorJwtProvider;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

/**
 * Intermediate representation of the Virgil Card with `contentSnapshot`
 * and `snapshot`s of the signatures in UTF-8.
 */
var RawSignedModel = /** @class */ (function () {
    /**
     * Initializes a new instance of `RawSignedModel`.
     * @param {string} contentSnapshot - The content snapshot in UTF-8.
     * @param {IRawSignature[]} signatures - The signatures. If signatures
     * themselves have snapshots, those must also be in UTF-8.
     */
    function RawSignedModel(contentSnapshot, signatures) {
        this.contentSnapshot = contentSnapshot;
        this.signatures = signatures;
    }
    /**
     * Converts the `str` in base64 encoding into a `RawSignedModel` object.
     *
     * @param {string} str - Base64 string representation of the card as
     * returned by {@RawSignedModel.toString} method.
     *
     * @returns {RawSignedModel}
     */
    RawSignedModel.fromString = function (str) {
        var jsonStr = base64Decode(str);
        var obj;
        try {
            obj = JSON.parse(jsonStr);
        }
        catch (error) {
            throw new Error('The string to be parsed is in invalid format');
        }
        return RawSignedModel.fromJson(obj);
    };
    /**
     * Converts the `json` serializable object into a `RawSignedModel` object.
     * @param {IRawSignedModelJson} json - JSON-serializable object returned by
     * {@link RawSignedModel.toJson} method.
     * @returns {RawSignedModel}
     */
    RawSignedModel.fromJson = function (json) {
        var contentSnapshotUtf8 = base64Decode(json.content_snapshot);
        var signaturesWithUtf8Snapshots = (json.signatures || []).map(function (_a) {
            var signer = _a.signer, signature = _a.signature, snapshot = _a.snapshot;
            if (snapshot) {
                return {
                    signer: signer,
                    signature: signature,
                    snapshot: base64Decode(snapshot)
                };
            }
            return { signer: signer, signature: signature };
        });
        return new RawSignedModel(contentSnapshotUtf8, signaturesWithUtf8Snapshots);
    };
    /**
     * This is to make it work with `JSON.stringify`, calls
     * {@link RawSignedModel.toJson} under the hood.
     * @returns {IRawSignedModelJson}
     */
    RawSignedModel.prototype.toJSON = function () {
        return this.toJson();
    };
    /**
     * Returns a JSON-serializable representation of this model in the
     * format it is stored in the Virgil Cards Service. (i.e. with
     * `contentSnapshot` and `snapshot`s of the signatures as base64 encoded
     * strings.
     * @returns {IRawSignedModelJson}
     */
    RawSignedModel.prototype.toJson = function () {
        return {
            content_snapshot: base64Encode(this.contentSnapshot),
            signatures: this.signatures.map(function (_a) {
                var signer = _a.signer, signature = _a.signature, snapshot = _a.snapshot;
                if (snapshot) {
                    return {
                        signer: signer,
                        signature: signature,
                        snapshot: base64Encode(snapshot)
                    };
                }
                return { signer: signer, signature: signature };
            })
        };
    };
    /**
     * Serializes this model to string in base64 encoding.
     * @returns {string}
     */
    RawSignedModel.prototype.toString = function () {
        return base64Encode(JSON.stringify(this));
    };
    /**
     * Same as {@link RawSignedModel.toJson}. Please use that instead.
     * @returns {IRawSignedModelJson}
     */
    RawSignedModel.prototype.exportAsJson = function () {
        return this.toJson();
    };
    /**
     * Same as {@link RawSignedModel.toString}. Please use that instead.
     * @returns {string}
     */
    RawSignedModel.prototype.exportAsString = function () {
        return this.toString();
    };
    return RawSignedModel;
}());

var fetchBrowser = createCommonjsModule(function (module, exports) {
(function (self) {

  function fetchPonyfill(options) {
    var Promise = options && options.Promise || self.Promise;
    var XMLHttpRequest = options && options.XMLHttpRequest || self.XMLHttpRequest;
    var global = self;

    return (function () {
      var self = Object.create(global, {
        fetch: {
          value: undefined,
          writable: true
        }
      });

      (function(self) {

        if (self.fetch) {
          return
        }

        var support = {
          searchParams: 'URLSearchParams' in self,
          iterable: 'Symbol' in self && 'iterator' in Symbol,
          blob: 'FileReader' in self && 'Blob' in self && (function() {
            try {
              new Blob();
              return true
            } catch(e) {
              return false
            }
          })(),
          formData: 'FormData' in self,
          arrayBuffer: 'ArrayBuffer' in self
        };

        if (support.arrayBuffer) {
          var viewClasses = [
            '[object Int8Array]',
            '[object Uint8Array]',
            '[object Uint8ClampedArray]',
            '[object Int16Array]',
            '[object Uint16Array]',
            '[object Int32Array]',
            '[object Uint32Array]',
            '[object Float32Array]',
            '[object Float64Array]'
          ];

          var isDataView = function(obj) {
            return obj && DataView.prototype.isPrototypeOf(obj)
          };

          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
          };
        }

        function normalizeName(name) {
          if (typeof name !== 'string') {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
            throw new TypeError('Invalid character in header field name')
          }
          return name.toLowerCase()
        }

        function normalizeValue(value) {
          if (typeof value !== 'string') {
            value = String(value);
          }
          return value
        }

        // Build a destructive iterator for the value list
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return {done: value === undefined, value: value}
            }
          };

          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator
            };
          }

          return iterator
        }

        function Headers(headers) {
          this.map = {};

          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }

        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue+','+value : value;
        };

        Headers.prototype['delete'] = function(name) {
          delete this.map[normalizeName(name)];
        };

        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null
        };

        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name))
        };

        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };

        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };

        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) { items.push(name); });
          return iteratorFor(items)
        };

        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) { items.push(value); });
          return iteratorFor(items)
        };

        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) { items.push([name, value]); });
          return iteratorFor(items)
        };

        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }

        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError('Already read'))
          }
          body.bodyUsed = true;
        }

        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          })
        }

        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise
        }

        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise
        }

        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);

          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join('')
        }

        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0)
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer
          }
        }

        function Body() {
          this.bodyUsed = false;

          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = '';
            } else if (typeof body === 'string') {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              // IE 10-11 can't handle a DataView body.
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              throw new Error('unsupported BodyInit type')
            }

            if (!this.headers.get('content-type')) {
              if (typeof body === 'string') {
                this.headers.set('content-type', 'text/plain;charset=UTF-8');
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set('content-type', this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
              }
            }
          };

          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected
              }

              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob)
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]))
              } else if (this._bodyFormData) {
                throw new Error('could not read FormData body as blob')
              } else {
                return Promise.resolve(new Blob([this._bodyText]))
              }
            };

            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
              } else {
                return this.blob().then(readBlobAsArrayBuffer)
              }
            };
          }

          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected
            }

            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob)
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
            } else if (this._bodyFormData) {
              throw new Error('could not read FormData body as text')
            } else {
              return Promise.resolve(this._bodyText)
            }
          };

          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode)
            };
          }

          this.json = function() {
            return this.text().then(JSON.parse)
          };

          return this
        }

        // HTTP methods whose capitalization should be normalized
        var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return (methods.indexOf(upcased) > -1) ? upcased : method
        }

        function Request(input, options) {
          options = options || {};
          var body = options.body;

          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError('Already read')
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }

          this.credentials = options.credentials || this.credentials || 'omit';
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || 'GET');
          this.mode = options.mode || this.mode || null;
          this.referrer = null;

          if ((this.method === 'GET' || this.method === 'HEAD') && body) {
            throw new TypeError('Body not allowed for GET or HEAD requests')
          }
          this._initBody(body);
        }

        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit })
        };

        function decode(body) {
          var form = new FormData();
          body.trim().split('&').forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split('=');
              var name = split.shift().replace(/\+/g, ' ');
              var value = split.join('=').replace(/\+/g, ' ');
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form
        }

        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
          // https://tools.ietf.org/html/rfc7230#section-3.2
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(':');
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(':').trim();
              headers.append(key, value);
            }
          });
          return headers
        }

        Body.call(Request.prototype);

        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }

          this.type = 'default';
          this.status = options.status === undefined ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = 'statusText' in options ? options.statusText : 'OK';
          this.headers = new Headers(options.headers);
          this.url = options.url || '';
          this._initBody(bodyInit);
        }

        Body.call(Response.prototype);

        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          })
        };

        Response.error = function() {
          var response = new Response(null, {status: 0, statusText: ''});
          response.type = 'error';
          return response
        };

        var redirectStatuses = [301, 302, 303, 307, 308];

        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError('Invalid status code')
          }

          return new Response(null, {status: status, headers: {location: url}})
        };

        self.Headers = Headers;
        self.Request = Request;
        self.Response = Response;

        self.fetch = function(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            var xhr = new XMLHttpRequest();

            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || '')
              };
              options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
              var body = 'response' in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };

            xhr.onerror = function() {
              reject(new TypeError('Network request failed'));
            };

            xhr.ontimeout = function() {
              reject(new TypeError('Network request failed'));
            };

            xhr.open(request.method, request.url, true);

            if (request.credentials === 'include') {
              xhr.withCredentials = true;
            } else if (request.credentials === 'omit') {
              xhr.withCredentials = false;
            }

            if ('responseType' in xhr && support.blob) {
              xhr.responseType = 'blob';
            }

            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });

            xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
          })
        };
        self.fetch.polyfill = true;
      })(typeof self !== 'undefined' ? self : this);


      return {
        fetch: self.fetch,
        Headers: self.Headers,
        Request: self.Request,
        Response: self.Response
      };
    }());
  }

  {
    module.exports = fetchPonyfill;
  }
}(typeof self !== 'undefined' ? self : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : commonjsGlobal));
});

var _a = fetchBrowser(), fetch = _a.fetch, Request = _a.Request, Response = _a.Response, Headers = _a.Headers;

var OS_LIST = [
    /* Windows Phone */
    {
        name: 'Windows Phone',
        test: [/windows phone/i],
    },
    /* Windows */
    {
        test: [/windows/i],
        name: 'Windows'
    },
    /* macOS */
    {
        test: [/macintosh/i],
        name: 'macOS'
    },
    /* iOS */
    {
        test: [/(ipod|iphone|ipad)/i],
        name: 'iOS'
    },
    /* Android */
    {
        test: [/android/i],
        name: 'Android',
    },
    /* Linux */
    {
        test: [/linux/i],
        name: 'Linux',
    },
    /* Chrome OS */
    {
        test: [/CrOS/],
        name: 'Chrome OS'
    },
    /* Playstation 4 */
    {
        test: [/PlayStation 4/],
        name: 'PlayStation 4',
    },
];

// Order of browsers matters! Edge, Opera and Chromium have Chrome in User Agent.
var BROWSER_LIST = [
    {
        test: [/googlebot/i],
        name: 'Googlebot'
    },
    {
        test: [/opera/i, /opr\/|opios/i],
        name: 'Opera',
    },
    {
        test: [/msie|trident/i],
        name: 'Internet Explorer',
    },
    {
        test: [/\sedg/i],
        name: 'Microsoft Edge'
    },
    {
        test: [/firefox|iceweasel|fxios/i],
        name: 'Firefox',
    },
    {
        test: [/chromium/i],
        name: 'Chromium'
    },
    {
        test: [/chrome|crios|crmo/i],
        name: 'Chrome',
    },
    {
        test: [/android/i],
        name: 'Android Browser'
    },
    {
        test: [/playstation 4/i],
        name: 'PlayStation 4',
    },
    {
        test: [/safari|applewebkit/i],
        name: 'Safari',
    }
];

/**
 * Class responsible for tracking which Virgil SDK is being used to make requests, its version,
 * browser and platform.
 */
var VirgilAgent = /** @class */ (function () {
    /**
     * Initializes a new instance of `VirgilAgent`.
     * @param {string} product - name of product eg (sdk, brainkey, bpp, keyknox, ratchet, e3kit, purekit)
     * argument of request methods.
     * @param {string} version - version of the product.
     * @param {string} [userAgent] - string with device user agent. Optional
     */
    function VirgilAgent(product, version, userAgent) {
        var _this = this;
        /**
         * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.
         * @return {boolean} true if detects Ionic.
         */
        this.isIonic = function () {
            return typeof window !== "undefined" &&
                !!("cordova" in window || "phonegap" in window || "PhoneGap" in window) &&
                /android|ios|iphone|ipod|ipad|iemobile/i.test(_this.userAgent);
        };
        this.userAgent = userAgent || this.getUserAgent();
        this.value = product + ";js;" + this.getHeaderValue() + ";" + version;
    }
    /**
     * Returns navigator.userAgent string or '' if it's not defined.
     * @return {string} user agent string
     */
    VirgilAgent.prototype.getUserAgent = function () {
        if (typeof navigator !== "undefined" && typeof navigator.userAgent === "string") {
            return navigator.userAgent;
        }
        else {
            return "";
        }
    };
    /**
     * Detects device OS
     * @returns {string} returns OS if detected or 'other'.
     */
    VirgilAgent.prototype.getOsName = function () {
        var _this = this;
        var os = OS_LIST.find(function (os) { return os.test.some(function (condition) { return condition.test(_this.userAgent); }); });
        return os ? os.name : 'other';
    };
    /**
     * Detects device browser
     * @returns {string} returns browser if detected of 'other'.
     */
    VirgilAgent.prototype.getBrowser = function () {
        var _this = this;
        var browser = BROWSER_LIST.find(function (browser) {
            return browser.test.some(function (condition) { return condition.test(_this.userAgent); });
        });
        return browser ? browser.name : 'other';
    };
    /**
     * Detect React Native.
     * @return {boolean} true if detects ReactNative .
     */
    VirgilAgent.prototype.isReactNative = function () {
        return typeof navigator === "object" && navigator.product === "ReactNative";
    };
    /**
     * Return information for `virgil-agent` header.
     * @return {string} string in format: PRODUCT;FAMILY;PLATFORM;VERSION
     */
    VirgilAgent.prototype.getHeaderValue = function () {
        try {
            if (this.isReactNative())
                return "ReactNative";
            if (this.isIonic())
                return "Ionic/" + this.getOsName();
            if (!true && typeof global !== 'undefined') {
                var majorVersion = process.version.replace(/\.\d+\.\d+$/, '').replace('v', '');
                return "Node" + majorVersion + "/" + process.platform;
            }
            return this.getBrowser() + "/" + this.getOsName();
        }
        catch (e) {
            return "Unknown";
        }
    };
    return VirgilAgent;
}());

/**
 * Class responsible for making HTTP requests.
 * @hidden
 */
var Connection = /** @class */ (function () {
    /**
     * Initializes a new instance of `Connection`.
     * @param {string} prefix - `prefix` will be prepended to the `endpoint`
     * argument of request methods.
     * @param {VirgilAgentValue} [virgilAgentValue] - optional instance of VirgilAgent for products that wraps
     * Virgil SDK
     */
    function Connection(prefix, info) {
        this.prefix = prefix;
        if (!info)
            info = { product: 'sdk', version: "6.1.0" };
        this.virgilAgentValue = new VirgilAgent(info.product, info.version).value;
    }
    /**
     * Issues a GET request against the `endpoint`.
     * @param {string} endpoint - Endpoint URL relative to the `prefix`.
     * @param {string} accessToken - Token to authenticate the request.
     * @returns {Promise<Response>}
     */
    Connection.prototype.get = function (endpoint, accessToken) {
        var headers = this.createHeaders(accessToken);
        return this.send(endpoint, 'GET', { headers: headers });
    };
    /**
     * Issues a POST request against the `endpoint` sending the `data` as JSON.
     * @param {string} endpoint - Endpoint URL relative to the `prefix`.
     * @param {string} accessToken - Token to authenticate the request.
     * @param {object} data - Response body.
     * @returns {Promise<Response>}
     */
    Connection.prototype.post = function (endpoint, accessToken, data) {
        if (data === void 0) { data = {}; }
        var headers = this.createHeaders(accessToken);
        headers.set('Content-Type', 'application/json');
        return this.send(endpoint, 'POST', {
            headers: headers,
            body: JSON.stringify(data)
        });
    };
    Connection.prototype.send = function (endpoint, method, params) {
        return fetch(this.prefix + endpoint, __assign({ method: method }, params));
    };
    Connection.prototype.createHeaders = function (accessToken) {
        var headers = new Headers();
        headers.set('Authorization', "Virgil " + accessToken);
        headers.set('Virgil-Agent', this.virgilAgentValue);
        return headers;
    };
    return Connection;
}());

/**
 * Custom error class for errors specific to Virgil SDK.
 */
var VirgilError = /** @class */ (function (_super) {
    __extends(VirgilError, _super);
    function VirgilError(m, name, DerivedClass) {
        if (name === void 0) { name = 'VirgilError'; }
        if (DerivedClass === void 0) { DerivedClass = VirgilError; }
        var _this = _super.call(this, m) || this;
        Object.setPrototypeOf(_this, DerivedClass.prototype);
        _this.name = name;
        return _this;
    }
    return VirgilError;
}(Error));

var ErrorCode;
(function (ErrorCode) {
    ErrorCode[ErrorCode["AccessTokenExpired"] = 20304] = "AccessTokenExpired";
    ErrorCode[ErrorCode["Unknown"] = 0] = "Unknown";
})(ErrorCode || (ErrorCode = {}));
/**
 * Error thrown by {@link CardManager} when request to the Virgil Cards Service
 * fails.
 */
var VirgilHttpError = /** @class */ (function (_super) {
    __extends(VirgilHttpError, _super);
    function VirgilHttpError(message, status, errorCode) {
        var _this = _super.call(this, message, 'VirgilHttpError', VirgilHttpError) || this;
        _this.httpStatus = status;
        _this.errorCode = errorCode;
        return _this;
    }
    return VirgilHttpError;
}(VirgilError));
/**
 * Generates error object from response object with HTTP status >= 400
 *
 * @hidden
 *
 * @param {Response} response
 * @returns {Promise<VirgilHttpError>}
 */
function generateErrorFromResponse(response) {
    return __awaiter(this, void 0, void 0, function () {
        var reason;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(response.status >= 400 && response.status < 500)) return [3 /*break*/, 2];
                    return [4 /*yield*/, response.json()];
                case 1:
                    reason = _a.sent();
                    return [2 /*return*/, new VirgilHttpError(reason.message, response.status, reason.code)];
                case 2: return [2 /*return*/, new VirgilHttpError(response.statusText, response.status, 0)];
            }
        });
    });
}

var PublishEndpoint = '/card/v5';
var SearchEndpoint = '/card/v5/actions/search';
var GetCardEndpoint = function (cardId) { return "/card/v5/" + cardId; };
var RevokeCardEndpoint = function (cardId) { return "/card/v5/actions/revoke/" + cardId; };
/**
 * Class responsible for sending requests to the Virgil Cards Service.
 *
 * @hidden
 */
var CardClient = /** @class */ (function () {
    /**
     * Initializes new instance of `CardClient`.
     * @param {IConnection | string} connection - Object implementing the
     * {@link IConnection} interface.
     */
    function CardClient(connection, productInfo) {
        if (typeof connection === 'string') {
            this.connection = new Connection(connection, productInfo);
        }
        else if (connection) {
            this.connection = connection;
        }
        else {
            this.connection = new Connection('https://api.virgilsecurity.com', productInfo);
        }
    }
    /**
     * Issues a request to search cards by the `identity`.
     * @param {string[]} identities - Array of identities to search for.
     * @param {string} accessToken - A token to authenticate the request.
     * @returns {Promise<RawSignedModel[]>}
     */
    CardClient.prototype.searchCards = function (identities, accessToken) {
        return __awaiter(this, void 0, void 0, function () {
            var response, cardsJson;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.connection.post(SearchEndpoint, accessToken, { identities: identities })];
                    case 1:
                        response = _a.sent();
                        if (!!response.ok) return [3 /*break*/, 3];
                        return [4 /*yield*/, generateErrorFromResponse(response)];
                    case 2: throw _a.sent();
                    case 3: return [4 /*yield*/, response.json()];
                    case 4:
                        cardsJson = _a.sent();
                        if (cardsJson === null)
                            return [2 /*return*/, []];
                        return [2 /*return*/, cardsJson.map(RawSignedModel.fromJson)];
                }
            });
        });
    };
    /**
     * Issues a request to get the card by id.
     * @param {string} cardId - Id of the card to fetch.
     * @param {string} accessToken - A token to authenticate the request.
     * @returns {Promise<ICardResult>}
     */
    CardClient.prototype.getCard = function (cardId, accessToken) {
        return __awaiter(this, void 0, void 0, function () {
            var response, isOutdated, cardJson, cardRaw;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!cardId)
                            throw new TypeError('`cardId` should not be empty');
                        if (!accessToken)
                            throw new TypeError('`accessToken` should not be empty');
                        return [4 /*yield*/, this.connection.get(GetCardEndpoint(cardId), accessToken)];
                    case 1:
                        response = _a.sent();
                        if (!!response.ok) return [3 /*break*/, 3];
                        return [4 /*yield*/, generateErrorFromResponse(response)];
                    case 2: throw _a.sent();
                    case 3:
                        isOutdated = response.headers.get('X-Virgil-Is-Superseeded') === 'true';
                        return [4 /*yield*/, response.json()];
                    case 4:
                        cardJson = _a.sent();
                        cardRaw = RawSignedModel.fromJson(cardJson);
                        return [2 /*return*/, { cardRaw: cardRaw, isOutdated: isOutdated }];
                }
            });
        });
    };
    /**
     * Issues a request to publish the card.
     * @param {RawSignedModel} model - Card to publish.
     * @param {string} accessToken - A token to authenticate the request.
     * @returns {Promise<RawSignedModel>}
     */
    CardClient.prototype.publishCard = function (model, accessToken) {
        return __awaiter(this, void 0, void 0, function () {
            var response, cardJson;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!model)
                            throw new TypeError('`model` should not be empty');
                        if (!accessToken)
                            throw new TypeError('`accessToken` should not be empty');
                        return [4 /*yield*/, this.connection.post(PublishEndpoint, accessToken, model)];
                    case 1:
                        response = _a.sent();
                        if (!!response.ok) return [3 /*break*/, 3];
                        return [4 /*yield*/, generateErrorFromResponse(response)];
                    case 2: throw _a.sent();
                    case 3: return [4 /*yield*/, response.json()];
                    case 4:
                        cardJson = _a.sent();
                        return [2 /*return*/, RawSignedModel.fromJson(cardJson)];
                }
            });
        });
    };
    CardClient.prototype.revokeCard = function (cardId, accessToken) {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!cardId)
                            throw new TypeError('`cardId` should not be empty');
                        if (!accessToken)
                            throw new TypeError('`accessToken` should not be empty');
                        return [4 /*yield*/, this.connection.post(RevokeCardEndpoint(cardId), accessToken)];
                    case 1:
                        response = _a.sent();
                        if (!!response.ok) return [3 /*break*/, 3];
                        return [4 /*yield*/, generateErrorFromResponse(response)];
                    case 2: throw _a.sent();
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    return CardClient;
}());

/**
 * @hidden
 */
var SelfSigner = "self";
/**
 * @hidden
 */
var VirgilSigner = "virgil";
/**
 * @hidden
 */
var CardVersion = '5.0';
/**
 * @hidden
 */
var CardIdByteLength = 32;

/**
 * Class responsible for generating signatures of the cards.
 */
var ModelSigner = /** @class */ (function () {
    /**
     * Initializes a new instance of `ModelSigner`.
     * @param {ICardCrypto} crypto - Object implementing the
     * {@link ICardCrypto} interface.
     */
    function ModelSigner(crypto) {
        this.crypto = crypto;
    }
    /**
     * Generates a new signature based on `rawParams`.
     * @param {IRawSignParams} rawParams
     */
    ModelSigner.prototype.sign = function (rawParams) {
        var _a = this.prepareParams(rawParams), model = _a.model, signerPrivateKey = _a.signerPrivateKey, signer = _a.signer, extraSnapshot = _a.extraSnapshot;
        var signedSnapshot = extraSnapshot != null
            ? model.contentSnapshot + extraSnapshot
            : model.contentSnapshot;
        var signature = this.crypto.generateSignature({ value: signedSnapshot, encoding: 'utf8' }, signerPrivateKey);
        model.signatures.push({
            signer: signer,
            signature: signature.toString('base64'),
            snapshot: extraSnapshot
        });
    };
    ModelSigner.prototype.prepareParams = function (_a) {
        var model = _a.model, signerPrivateKey = _a.signerPrivateKey, extraFields = _a.extraFields, signer = _a.signer;
        signer = signer || SelfSigner;
        var extraSnapshot;
        if (extraFields != null) {
            extraSnapshot = JSON.stringify(extraFields);
        }
        var final = { model: model, signerPrivateKey: signerPrivateKey, signer: signer, extraSnapshot: extraSnapshot };
        this.validate(final);
        return final;
    };
    ModelSigner.prototype.validate = function (_a) {
        var model = _a.model, signerPrivateKey = _a.signerPrivateKey, signer = _a.signer;
        if (model == null) {
            throw new Error("Model is empty");
        }
        if (signerPrivateKey == null) {
            throw new Error("`signerPrivateKey` property is mandatory");
        }
        if (model.signatures != null && model.signatures.some(function (s) { return s.signer == signer; })) {
            throw new Error("The model already has this signature.");
        }
    };
    return ModelSigner;
}());

/**
 * Converts an {@link ICard} to a {@link RawSignedModel}.
 *
 * @hidden
 *
 * @param {ICard} card - The {@link ICard} to convert.
 * @returns {RawSignedModel}
 */
function cardToRawSignedModel(card) {
    return new RawSignedModel(card.contentSnapshot, card.signatures.slice());
}
/**
 * Generates a {@link RawSignedModel} from the given `params`.
 *
 * @hidden
 *
 * @param {ICardCrypto} crypto - Object implementing the {@link ICardCrypto}
 * interface.
 * @param {INewCardParams} params - New card parameters.
 * @returns {RawSignedModel}
 */
function generateRawSigned(crypto, params) {
    var identity = params.identity, publicKey = params.publicKey, previousCardId = params.previousCardId;
    var now = getUnixTimestamp(new Date);
    var details = {
        identity: identity,
        previous_card_id: previousCardId,
        created_at: now,
        version: CardVersion,
        public_key: crypto.exportPublicKey(publicKey).toString('base64'),
    };
    return new RawSignedModel(JSON.stringify(details), []);
}
/**
 * Converts the {@link RawSignedModel} into the {@link ICard}.
 *
 * @hidden
 *
 * @param {ICardCrypto} crypto - Object implementing the {@link ICardCrypto}
 * interface.
 * @param {RawSignedModel} model - The model to convert.
 * @param {boolean} isOutdated - Boolean indicating whether there is a newer
 * Virgil Card replacing the one that `model` represents.
 *
 * @returns {ICard}
 */
function parseRawSignedModel(crypto, model, isOutdated) {
    if (isOutdated === void 0) { isOutdated = false; }
    var content = JSON.parse(model.contentSnapshot);
    var signatures = model.signatures.map(rawSignToCardSign);
    return {
        id: generateCardId(crypto, model.contentSnapshot),
        publicKey: crypto.importPublicKey({ value: content.public_key, encoding: 'base64' }),
        contentSnapshot: model.contentSnapshot,
        identity: content.identity,
        version: content.version,
        createdAt: new Date(content.created_at * 1000),
        previousCardId: content.previous_card_id,
        signatures: signatures,
        isOutdated: isOutdated
    };
}
/**
 * Given the array of `cards`, returns another array with outdated cards
 * filtered out and the `previousCard` properties of the cards that replace
 * the outdated ones being populated with appropriate outdated cards.
 * i.e. turns this (A is for Actual, O is for Outdated):
 * ```
 * A -> O -> A -> A -> O
 * ```
 * into this
 * ```
 * A -> A -> A
 * |         |
 * O         O
 * ```
 *
 * @hidden
 *
 * @param {ICard[]} cards - The cards array to transform.
 * @returns {ICard[]} - Transformed array.
 */
function linkedCardList(cards) {
    var unsorted = Object.create(null);
    for (var _i = 0, cards_1 = cards; _i < cards_1.length; _i++) {
        var card = cards_1[_i];
        unsorted[card.id] = card;
    }
    for (var _a = 0, cards_2 = cards; _a < cards_2.length; _a++) {
        var card = cards_2[_a];
        if (card.previousCardId == null)
            continue;
        if (unsorted[card.previousCardId] == null)
            continue;
        unsorted[card.previousCardId].isOutdated = true;
        card.previousCard = unsorted[card.previousCardId];
        delete unsorted[card.previousCardId];
    }
    return Object.keys(unsorted).map(function (key) { return unsorted[key]; });
}
/**
 * Calculates ID for the VirgilCard from the `snapshot` of its contents.
 *
 * @hidden
 *
 * @param {ICardCrypto} crypto - Object implementing the {@link ICardCrypto}
 * interface.
 * @param {string} snapshot - The VirgilCard's contents snapshot.
 * @returns {string} - VirgilCard's ID encoded in HEX.
 */
function generateCardId(crypto, snapshot) {
    var fingerprint = crypto
        .generateSha512({ value: snapshot, encoding: 'utf8' })
        .slice(0, CardIdByteLength);
    return fingerprint.toString('hex');
}
function rawSignToCardSign(_a) {
    var snapshot = _a.snapshot, signature = _a.signature, signer = _a.signer;
    return {
        signer: signer,
        signature: signature,
        snapshot: snapshot,
        extraFields: tryParseExtraFields(snapshot)
    };
}
function tryParseExtraFields(snapshot) {
    if (snapshot) {
        try {
            return JSON.parse(snapshot);
        }
        catch (ignored) { }
    }
    return {};
}

/**
 * Error thrown by {@link CardManager} instances when the card received from
 * the network (or imported from string\json) fails verification.
 */
var VirgilCardVerificationError = /** @class */ (function (_super) {
    __extends(VirgilCardVerificationError, _super);
    function VirgilCardVerificationError(m) {
        return _super.call(this, m, 'CardVerificationError', VirgilCardVerificationError) || this;
    }
    return VirgilCardVerificationError;
}(VirgilError));

var CARDS_SERVICE__NAME = 'cards';
/**
 * @hidden
 */
var throwingAccessTokenProvider = {
    getToken: function () {
        throw new Error('Please set `CardManager.accessTokenProvider` to be able to make requests.');
    }
};
var getCardServiceTokenContext = function (context) { return (__assign(__assign({}, context), { service: CARDS_SERVICE__NAME })); };
/**
 * Class responsible for creating, publishing and retrieving Virgil Cards.
 */
var CardManager = /** @class */ (function () {
    function CardManager(params) {
        this.crypto = params.cardCrypto;
        this.client = new CardClient(params.apiUrl, params.productInfo);
        this.modelSigner = new ModelSigner(params.cardCrypto);
        this.signCallback = params.signCallback;
        this.retryOnUnauthorized = params.retryOnUnauthorized;
        this.cardVerifier = params.cardVerifier;
        this.accessTokenProvider = params.accessTokenProvider || throwingAccessTokenProvider;
    }
    /**
     * Generates a {@link RawSignedModel} that represents a card from
     * `cardParams`.
     * Use this method if you don't need to publish the card right away, for
     * example if you need to first send it to your backend server to apply
     * additional signature.
     *
     * @param {INewCardParams} cardParams - New card parameters.
     * @returns {RawSignedModel}
     */
    CardManager.prototype.generateRawCard = function (cardParams) {
        var model = generateRawSigned(this.crypto, cardParams);
        this.modelSigner.sign({
            model: model,
            signerPrivateKey: cardParams.privateKey,
            signer: SelfSigner,
            extraFields: cardParams.extraFields
        });
        return model;
    };
    /**
     * Generates a card from `cardParams` and publishes it in the Virgil Cards
     * Service.
     * @param {INewCardParams} cardParams - New card parameters.
     * @returns {Promise<ICard>}
     */
    CardManager.prototype.publishCard = function (cardParams) {
        return __awaiter(this, void 0, void 0, function () {
            var tokenContext, token, rawSignedModel;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        validateCardParams(cardParams);
                        tokenContext = {
                            service: CARDS_SERVICE__NAME,
                            identity: cardParams.identity,
                            operation: 'publish'
                        };
                        return [4 /*yield*/, this.accessTokenProvider.getToken(tokenContext)];
                    case 1:
                        token = _a.sent();
                        rawSignedModel = this.generateRawCard(Object.assign({}, cardParams, { identity: token.identity() }));
                        return [4 /*yield*/, this.publishRawSignedModel(rawSignedModel, tokenContext, token)];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Publishes a previously generated card in the form of
     * {@link RawSignedModel} object.
     *
     * @param {RawSignedModel} rawCard - The card to publish.
     * @returns {Promise<ICard>}
     */
    CardManager.prototype.publishRawCard = function (rawCard) {
        return __awaiter(this, void 0, void 0, function () {
            var cardDetails, tokenContext, token;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        assert(rawCard != null && rawCard.contentSnapshot != null, '`rawCard` should not be empty');
                        cardDetails = JSON.parse(rawCard.contentSnapshot);
                        tokenContext = getCardServiceTokenContext({ identity: cardDetails.identity, operation: 'publish' });
                        return [4 /*yield*/, this.accessTokenProvider.getToken(tokenContext)];
                    case 1:
                        token = _a.sent();
                        return [2 /*return*/, this.publishRawSignedModel(rawCard, tokenContext, token)];
                }
            });
        });
    };
    /**
     * Fetches the card by `cardId` from the Virgil Card Service.
     * @param {string} cardId - Id of the card to fetch.
     * @returns {Promise<ICard>}
     */
    CardManager.prototype.getCard = function (cardId) {
        return __awaiter(this, void 0, void 0, function () {
            var tokenContext, accessToken, cardWithStatus, card;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tokenContext = getCardServiceTokenContext({ operation: 'get' });
                        return [4 /*yield*/, this.accessTokenProvider.getToken(tokenContext)];
                    case 1:
                        accessToken = _a.sent();
                        return [4 /*yield*/, this.tryDo(tokenContext, accessToken, function (token) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this.client.getCard(cardId, token.toString())];
                                    case 1: return [2 /*return*/, _a.sent()];
                                }
                            }); }); })];
                    case 2:
                        cardWithStatus = _a.sent();
                        card = parseRawSignedModel(this.crypto, cardWithStatus.cardRaw, cardWithStatus.isOutdated);
                        if (card.id !== cardId) {
                            throw new VirgilCardVerificationError('Received invalid card');
                        }
                        this.validateCards([card]);
                        return [2 /*return*/, card];
                }
            });
        });
    };
    /**
     * Fetches collection of cards with the given `identity` from the Virgil
     * Cards Service.
     * @param {string|string[]} identities - Identity or an array of identities of the cards to fetch.
     * @returns {Promise<ICard[]>}
     */
    CardManager.prototype.searchCards = function (identities) {
        return __awaiter(this, void 0, void 0, function () {
            var identitiesArr, tokenContext, accessToken, rawCards, cards, identitiesSet;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!identities)
                            throw new TypeError('Argument `identities` is required');
                        identitiesArr = Array.isArray(identities) ? identities : [identities];
                        if (identitiesArr.length === 0)
                            throw new TypeError('Identities array must not be empty');
                        tokenContext = getCardServiceTokenContext({ operation: 'search' });
                        return [4 /*yield*/, this.accessTokenProvider.getToken(tokenContext)];
                    case 1:
                        accessToken = _a.sent();
                        return [4 /*yield*/, this.tryDo(tokenContext, accessToken, function (token) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this.client.searchCards(identitiesArr, token.toString())];
                                    case 1: return [2 /*return*/, _a.sent()];
                                }
                            }); }); })];
                    case 2:
                        rawCards = _a.sent();
                        cards = rawCards.map(function (raw) { return parseRawSignedModel(_this.crypto, raw, false); });
                        identitiesSet = new Set(identitiesArr);
                        if (cards.some(function (c) { return !identitiesSet.has(c.identity); })) {
                            throw new VirgilCardVerificationError('Received invalid cards');
                        }
                        this.validateCards(cards);
                        return [2 /*return*/, linkedCardList(cards)];
                }
            });
        });
    };
    /**
     * Marks the Virgil Card specified by `cardId` as revoked.  Revoked cards will have `isOutdated`
     * property set to `true` when retrieved via {@link CardManager.getCard} method.
     * Also revoked cards will be absent in the {@link CardManager.searchCards} result.
     * @param {string} cardId - Id of the card to revoke.
     * @returns {Promise}
     */
    CardManager.prototype.revokeCard = function (cardId) {
        return __awaiter(this, void 0, void 0, function () {
            var tokenContext, accessToken;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!cardId)
                            throw new TypeError('Argument `cardId` is required');
                        tokenContext = getCardServiceTokenContext({ operation: 'revoke' });
                        return [4 /*yield*/, this.accessTokenProvider.getToken(tokenContext)];
                    case 1:
                        accessToken = _a.sent();
                        return [4 /*yield*/, this.tryDo(tokenContext, accessToken, function (token) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this.client.revokeCard(cardId, token.toString())];
                                    case 1: return [2 /*return*/, _a.sent()];
                                }
                            }); }); })];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Converts the card in the form of {@link RawSignedModel} object to the
     * {@link ICard} object.
     *
     * @see {@link CardManager.exportCard}
     *
     * @param {RawSignedModel} rawCard - The card to convert.
     * @returns {ICard}
     */
    CardManager.prototype.importCard = function (rawCard) {
        var card = parseRawSignedModel(this.crypto, rawCard);
        this.validateCards([card]);
        return card;
    };
    /**
     * Converts the card in the base64 string form to the {@link ICard} object.
     *
     * @see {@link CardManager.exportCardAsString}
     *
     * @param {string} str - The string in base64.
     * @returns {ICard}
     */
    CardManager.prototype.importCardFromString = function (str) {
        assert(Boolean(str), '`str` should not be empty');
        return this.importCard(RawSignedModel.fromString(str));
    };
    /**
     * Converts the card in the JSON-serializable object form to the
     * {@link ICard} object.
     *
     * @see {@link CardManager.exportCardAsJson}
     *
     * @param {IRawSignedModelJson} json
     * @returns {ICard}
     */
    CardManager.prototype.importCardFromJson = function (json) {
        assert(Boolean(json), '`json` should not be empty');
        return this.importCard(RawSignedModel.fromJson(json));
    };
    /**
     * Converts the card in the form of {@link ICard} object to the
     * {@link RawSignedModel} object.
     *
     * @see {@link CardManager.importCard}
     *
     * @param {ICard} card
     * @returns {RawSignedModel}
     */
    CardManager.prototype.exportCard = function (card) {
        return cardToRawSignedModel(card);
    };
    /**
     * Converts the card in the form of {@link ICard} object to the string
     * in base64 encoding.
     *
     * @see {@link CardManager.importCardFromString}
     *
     * @param {ICard} card
     * @returns {string}
     */
    CardManager.prototype.exportCardAsString = function (card) {
        return this.exportCard(card).toString();
    };
    /**
     * Converts the card in the form of {@link ICard} object to the
     * JSON-serializable object form.
     *
     * @see {@link CardManager.importCardFromJson}
     *
     * @param {ICard} card
     * @returns {IRawSignedModelJson}
     */
    CardManager.prototype.exportCardAsJson = function (card) {
        return this.exportCard(card).toJson();
    };
    /**
     * @hidden
     */
    CardManager.prototype.publishRawSignedModel = function (rawCard, context, accessToken) {
        return __awaiter(this, void 0, void 0, function () {
            var publishedModel, card;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.signCallback != null)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.signCallback(rawCard)];
                    case 1:
                        rawCard = _a.sent();
                        _a.label = 2;
                    case 2: return [4 /*yield*/, this.tryDo(context, accessToken, function (token) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.client.publishCard(rawCard, token.toString())];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        }); }); })];
                    case 3:
                        publishedModel = _a.sent();
                        if (rawCard.contentSnapshot !== publishedModel.contentSnapshot) {
                            throw new VirgilCardVerificationError('Received invalid card');
                        }
                        card = parseRawSignedModel(this.crypto, publishedModel);
                        this.validateCards([card]);
                        return [2 /*return*/, card];
                }
            });
        });
    };
    /**
     * @hidden
     */
    CardManager.prototype.tryDo = function (context, token, func) {
        return __awaiter(this, void 0, void 0, function () {
            var e_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 6]);
                        return [4 /*yield*/, func(token)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2:
                        e_1 = _a.sent();
                        if (!(e_1 instanceof VirgilHttpError &&
                            e_1.httpStatus === 401 &&
                            e_1.errorCode === ErrorCode.AccessTokenExpired &&
                            this.retryOnUnauthorized)) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.accessTokenProvider.getToken(getCardServiceTokenContext({
                                identity: context.identity,
                                operation: context.operation,
                                forceReload: true
                            }))];
                    case 3:
                        token = _a.sent();
                        return [4 /*yield*/, func(token)];
                    case 4: return [2 /*return*/, _a.sent()];
                    case 5: throw e_1;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Delegates to the {@link CardManager.cardVerifier} to verify the validity
     * of the `cards`.
     *
     * @throws {@link VirgilCardVerificationError} if any of the cards is not
     * valid.
     *
     * @param {ICard[]} cards
     */
    CardManager.prototype.validateCards = function (cards) {
        if (this.cardVerifier == null)
            return;
        for (var _i = 0, cards_1 = cards; _i < cards_1.length; _i++) {
            var card = cards_1[_i];
            if (!this.cardVerifier.verifyCard(card)) {
                throw new VirgilCardVerificationError('Validation errors have been detected');
            }
        }
    };
    return CardManager;
}());
/**
 * @hidden
 */
function validateCardParams(params, validateIdentity) {
    if (validateIdentity === void 0) { validateIdentity = false; }
    assert(params != null, 'Card parameters must be provided');
    assert(params.privateKey != null, 'Card\'s private key is required');
    assert(params.publicKey != null, 'Card\'s public key is required');
    if (validateIdentity) {
        assert(typeof params.identity === 'string' && params.identity !== '', 'Card\'s identity is required');
    }
}

var DEFAULTS = {
    verifySelfSignature: true,
    verifyVirgilSignature: true,
    whitelists: []
};
var VIRGIL_CARDS_PUBKEY_BASE64 = 'MCowBQYDK2VwAyEAljOYGANYiVq1WbvVvoYIKtvZi2ji9bAhxyu6iV/LF8M=';
/**
 * Class responsible for validating cards by verifying their digital
 * signatures.
 */
var VirgilCardVerifier = /** @class */ (function () {
    /**
     * Initializes a new instance of `VirgilCardVerifier`.
     * @param {ICardCrypto} crypto - Object implementing the
     * {@link ICardCrypto} interface.
     * @param {IVirgilCardVerifierParams} options - Initialization options.
     */
    function VirgilCardVerifier(crypto, options) {
        this.crypto = crypto;
        var params = __assign(__assign({}, DEFAULTS), (options || {}));
        this.verifySelfSignature = params.verifySelfSignature;
        this.verifyVirgilSignature = params.verifyVirgilSignature;
        this.whitelists = params.whitelists;
        this.virgilCardsPublicKey = crypto.importPublicKey({ value: VIRGIL_CARDS_PUBKEY_BASE64, encoding: 'base64' });
    }
    /**
     * Verifies the signatures of the `card`.
     * @param {ICard} card
     * @returns {boolean} `true` if the signatures to be verified are present
     * and valid, otherwise `false`.
     */
    VirgilCardVerifier.prototype.verifyCard = function (card) {
        var _this = this;
        if (this.selfValidationFailed(card)) {
            return false;
        }
        if (this.virgilValidationFailed(card)) {
            return false;
        }
        if (!this.whitelists || this.whitelists.length === 0) {
            return true;
        }
        var signers = card.signatures.map(function (s) { return s.signer; });
        for (var _i = 0, _a = this.whitelists; _i < _a.length; _i++) {
            var whitelist = _a[_i];
            if (whitelist == null || whitelist.length === 0) {
                return false;
            }
            var intersectedCreds = whitelist.filter(function (x) { return signers.indexOf(x.signer) !== -1; });
            if (intersectedCreds.length === 0) {
                return false;
            }
            var isValidForSome = intersectedCreds.some(function (cred) {
                return _this.validateSignerSignature(card, _this.getPublicKey(cred.publicKeyBase64), cred.signer);
            });
            if (!isValidForSome) {
                return false;
            }
        }
        return true;
    };
    VirgilCardVerifier.prototype.selfValidationFailed = function (card) {
        return this.verifySelfSignature
            && !this.validateSignerSignature(card, card.publicKey, SelfSigner);
    };
    VirgilCardVerifier.prototype.virgilValidationFailed = function (card) {
        return this.verifyVirgilSignature
            && !this.validateSignerSignature(card, this.virgilCardsPublicKey, VirgilSigner);
    };
    VirgilCardVerifier.prototype.getPublicKey = function (signerPublicKeyBase64) {
        return this.crypto.importPublicKey({ value: signerPublicKeyBase64, encoding: 'base64' });
    };
    VirgilCardVerifier.prototype.validateSignerSignature = function (card, signerPublicKey, signer) {
        var signature = card.signatures.find(function (s) { return s.signer === signer; });
        if (signature == null)
            return false;
        var extendedSnapshot = signature.snapshot == null
            ? card.contentSnapshot
            : card.contentSnapshot + signature.snapshot;
        return this.crypto.verifySignature({ value: extendedSnapshot, encoding: 'utf8' }, { value: signature.signature, encoding: 'base64' }, signerPublicKey);
    };
    return VirgilCardVerifier;
}());

var utf8 = createCommonjsModule(function (module, exports) {
(function(root) {

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	root.version = '3.0.0';
	root.encode = utf8encode;
	root.decode = utf8decode;

}( exports));
});

// Some code originally from localForage
// See: https://github.com/localForage/localForage/blob/master/src/utils/isIndexedDBValid.js
/**
 * @hidden
 * @returns {boolean}
 */
function isIndexedDbValid() {
    // We mimic PouchDB here
    // Following #7085 (see https://github.com/pouchdb/pouchdb/issues/7085)
    // buggy idb versions (typically Safari < 10.1) are considered valid.
    // On Firefox SecurityError is thrown while referencing indexedDB if cookies
    // are not allowed. `typeof indexedDB` also triggers the error.
    try {
        // some outdated implementations of IDB that appear on Samsung
        // and HTC Android devices <4.4 are missing IDBKeyRange
        return typeof indexedDB !== 'undefined' && typeof IDBKeyRange !== 'undefined';
    }
    catch (e) {
        return false;
    }
}

/**
 * Error thrown by {@link IStorageAdapter.store} method when saving a value
 * with a key that already exists in store.
 */
var StorageEntryAlreadyExistsError = /** @class */ (function (_super) {
    __extends(StorageEntryAlreadyExistsError, _super);
    function StorageEntryAlreadyExistsError(key) {
        return _super.call(this, "Storage entry " + (key ? 'with key ' + name : 'with the given key') + "already exists", 'StorageEntryAlreadyExistsError', StorageEntryAlreadyExistsError) || this;
    }
    return StorageEntryAlreadyExistsError;
}(VirgilError));

// Some code originally from localForage in
// [localForage](https://github.com/localForage/localForage).
// Transaction Modes
var READ_ONLY = 'readonly';
var READ_WRITE = 'readwrite';
var dbContexts = {};
/**
 * Implementation of {@link IStorageAdapter} that uses IndexedDB for
 * persistence. For use in browsers.
 */
var IndexedDbStorageAdapter = /** @class */ (function () {
    /**
     * Initializes an instance of `IndexedDbStorageAdapter`.
     * @param {IStorageAdapterConfig} config - Configuration options.
     * Currently only `name` is supported and must be the name of the
     * IndexedDB database where the data will be stored.
     */
    function IndexedDbStorageAdapter(config) {
        var _this = this;
        // Open the IndexedDB database (automatically creates one if one didn't
        // previously exist), using any options set in the config.
        this._initStorage = function () {
            var dbInfo = {
                db: null,
                name: _this._defaultConfig.name,
                storeName: _this._defaultConfig.storeName,
                version: _this._defaultConfig.version
            };
            // Get the current context of the database;
            var dbContext = dbContexts[dbInfo.name];
            // ...or create a new context.
            if (!dbContext) {
                dbContext = createDbContext();
                // Register the new context in the global container.
                dbContexts[dbInfo.name] = dbContext;
            }
            // Initialize the connection process only when
            // all the related storages aren't pending.
            return Promise.resolve()
                .then(function () {
                dbInfo.db = dbContext.db;
                // Get the connection or open a new one without upgrade.
                return _getOriginalConnection(dbInfo);
            })
                .then(function (db) {
                dbInfo.db = db;
                if (_isUpgradeNeeded(dbInfo, _this._defaultConfig.version)) {
                    // Reopen the database for upgrading.
                    return _getUpgradedConnection(dbInfo);
                }
                return db;
            })
                .then(function (db) {
                dbInfo.db = dbContext.db = db;
                _this._dbInfo = dbInfo;
            });
        };
        // Specialize the default `ready()` function by making it dependent
        // on the current database operations. Thus, the driver will be actually
        // ready when it's been initialized (default) *and* there are no pending
        // operations on the database (initiated by some other instances).
        this.ready = function () {
            var promise = _this._ready.then(function () {
                var dbContext = dbContexts[_this._dbInfo.name];
                if (dbContext && dbContext.dbReady) {
                    return dbContext.dbReady;
                }
            });
            return promise;
        };
        if (!isIndexedDbValid()) {
            throw new Error('Cannot use IndexedDbStorageAdapter. indexedDb is not supported');
        }
        this._defaultConfig = {
            name: config.name,
            version: 1,
            storeName: 'keyvaluepairs'
        };
        this._ready = this._initStorage();
    }
    /**
     * @inheritDoc
     */
    IndexedDbStorageAdapter.prototype.store = function (key, data) {
        var _this = this;
        key = normalizeKey(key);
        return new Promise(function (resolve, reject) {
            _this.ready().then(function () {
                createTransaction(_this._dbInfo, READ_WRITE, function (err, transaction) {
                    if (err) {
                        return reject(err);
                    }
                    try {
                        var store = transaction.objectStore(_this._dbInfo.storeName);
                        var req_1 = store.add(data, key);
                        transaction.oncomplete = function () {
                            resolve();
                        };
                        transaction.onabort = transaction.onerror = function () {
                            var error = req_1.error
                                ? req_1.error
                                : req_1.transaction.error;
                            if (error && error.name === 'ConstraintError') {
                                reject(new StorageEntryAlreadyExistsError(key));
                            }
                            reject(error);
                        };
                    }
                    catch (error) {
                        reject(error);
                    }
                });
            }).catch(reject);
        });
    };
    /**
     * @inheritDoc
     */
    IndexedDbStorageAdapter.prototype.load = function (key) {
        var _this = this;
        key = normalizeKey(key);
        return new Promise(function (resolve, reject) {
            _this.ready().then(function () {
                createTransaction(_this._dbInfo, READ_ONLY, function (err, transaction) {
                    if (err) {
                        return reject(err);
                    }
                    try {
                        var store = transaction.objectStore(_this._dbInfo.storeName);
                        var req_2 = store.get(key);
                        req_2.onsuccess = function () {
                            if (req_2.result == null) {
                                return resolve(null);
                            }
                            resolve(convertDbValue(req_2.result));
                        };
                        req_2.onerror = function () {
                            reject(req_2.error);
                        };
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            }).catch(reject);
        });
    };
    /**
     * @inheritDoc
     */
    IndexedDbStorageAdapter.prototype.exists = function (key) {
        var _this = this;
        key = normalizeKey(key);
        return new Promise(function (resolve, reject) {
            _this.ready().then(function () {
                createTransaction(_this._dbInfo, READ_ONLY, function (err, transaction) {
                    if (err) {
                        return reject(err);
                    }
                    try {
                        var store = transaction.objectStore(_this._dbInfo.storeName);
                        var req_3 = store.openCursor(key);
                        req_3.onsuccess = function () {
                            var cursor = req_3.result;
                            resolve(cursor !== null);
                        };
                        req_3.onerror = function () {
                            reject(req_3.error);
                        };
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            }).catch(reject);
        });
    };
    /**
     * @inheritDoc
     */
    IndexedDbStorageAdapter.prototype.remove = function (key) {
        var _this = this;
        key = normalizeKey(key);
        return new Promise(function (resolve, reject) {
            _this.ready().then(function () {
                createTransaction(_this._dbInfo, READ_WRITE, function (err, transaction) {
                    if (err) {
                        return reject(err);
                    }
                    try {
                        var store_1 = transaction.objectStore(_this._dbInfo.storeName);
                        var countReq_1 = store_1.count(key);
                        var delReq_1;
                        countReq_1.onsuccess = function () {
                            var count = countReq_1.result;
                            if (count === 0) {
                                return resolve(false);
                            }
                            // safe for IE and some versions of Android
                            // (including those used by Cordova).
                            // Normally IE won't like `.delete()` and will insist on
                            // using `['delete']()`
                            delReq_1 = store_1['delete'](key);
                            delReq_1.onsuccess = function () { return resolve(true); };
                        };
                        // The request will be also be aborted if we've exceeded our storage
                        // space.
                        transaction.onabort = transaction.onerror = function () {
                            var req = delReq_1 || countReq_1;
                            var err = req.error
                                ? req.error
                                : req.transaction.error;
                            reject(err);
                        };
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            }).catch(reject);
        });
    };
    /**
     * @inheritDoc
     */
    IndexedDbStorageAdapter.prototype.update = function (key, data) {
        var _this = this;
        key = normalizeKey(key);
        return new Promise(function (resolve, reject) {
            _this.ready().then(function () {
                createTransaction(_this._dbInfo, READ_WRITE, function (err, transaction) {
                    if (err) {
                        return reject(err);
                    }
                    try {
                        var store = transaction.objectStore(_this._dbInfo.storeName);
                        var req_4 = store.put(data, key);
                        req_4.onsuccess = function () {
                            resolve();
                        };
                        req_4.onerror = function () {
                            reject(req_4.error);
                        };
                    }
                    catch (error) {
                        reject(error);
                    }
                });
            }).catch(reject);
        });
    };
    /**
     * @inheritDoc
     */
    IndexedDbStorageAdapter.prototype.clear = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.ready().then(function () {
                createTransaction(_this._dbInfo, READ_WRITE, function (err, transaction) {
                    if (err) {
                        return reject(err);
                    }
                    try {
                        var store = transaction.objectStore(_this._dbInfo.storeName);
                        var req_5 = store.clear();
                        transaction.oncomplete = function () { return resolve(); };
                        transaction.onabort = transaction.onerror = function () {
                            var err = req_5.error
                                ? req_5.error
                                : req_5.transaction.error;
                            reject(err);
                        };
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            }).catch(reject);
        });
    };
    /**
     * @inheritDoc
     */
    IndexedDbStorageAdapter.prototype.list = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.ready().then(function () {
                createTransaction(_this._dbInfo, READ_ONLY, function (err, transaction) {
                    if (err) {
                        return reject(err);
                    }
                    try {
                        var store = transaction.objectStore(_this._dbInfo.storeName);
                        var req_6 = store.openCursor();
                        var entries_1 = [];
                        req_6.onsuccess = function () {
                            var cursor = req_6.result;
                            if (!cursor) {
                                resolve(entries_1);
                            }
                            else {
                                entries_1.push(convertDbValue(cursor.value));
                                cursor.continue();
                            }
                        };
                        req_6.onerror = function () {
                            reject(req_6.error);
                        };
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            }).catch(reject);
        });
    };
    return IndexedDbStorageAdapter;
}());
function createDbContext() {
    return {
        // Database.
        db: null,
        // Database readiness (promise).
        dbReady: null,
        // Deferred operations on the database.
        deferredOperations: []
    };
}
function _deferReadiness(dbInfo) {
    var dbContext = dbContexts[dbInfo.name];
    // Create a deferred object representing the current database operation.
    var deferredOperation = {};
    deferredOperation.promise = new Promise(function (resolve, reject) {
        deferredOperation.resolve = resolve;
        deferredOperation.reject = reject;
    });
    // Enqueue the deferred operation.
    dbContext.deferredOperations.push(deferredOperation);
    // Chain its promise to the database readiness.
    if (!dbContext.dbReady) {
        dbContext.dbReady = deferredOperation.promise;
    }
    else {
        dbContext.dbReady = dbContext.dbReady.then(function () { return deferredOperation.promise; });
    }
}
function _advanceReadiness(dbInfo) {
    var dbContext = dbContexts[dbInfo.name];
    // Dequeue a deferred operation.
    var deferredOperation = dbContext.deferredOperations.pop();
    // Resolve its promise (which is part of the database readiness
    // chain of promises).
    if (deferredOperation) {
        deferredOperation.resolve();
        return deferredOperation.promise;
    }
}
function _rejectReadiness(dbInfo, err) {
    var dbContext = dbContexts[dbInfo.name];
    // Dequeue a deferred operation.
    var deferredOperation = dbContext.deferredOperations.pop();
    // Reject its promise (which is part of the database readiness
    // chain of promises).
    if (deferredOperation) {
        deferredOperation.reject(err);
        return deferredOperation.promise;
    }
}
function _getConnection(dbInfo, upgradeNeeded) {
    return new Promise(function (resolve, reject) {
        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();
        if (dbInfo.db) {
            if (upgradeNeeded) {
                _deferReadiness(dbInfo);
                dbInfo.db.close();
            }
            else {
                return resolve(dbInfo.db);
            }
        }
        var dbArgs = [dbInfo.name];
        if (upgradeNeeded) {
            dbArgs.push(String(dbInfo.version));
        }
        var openReq = indexedDB.open.apply(indexedDB, dbArgs);
        if (upgradeNeeded) {
            openReq.onupgradeneeded = function (e) {
                var db = openReq.result;
                try {
                    db.createObjectStore(dbInfo.storeName);
                }
                catch (ex) {
                    if (ex.name === 'ConstraintError') {
                        console.warn('The database "' +
                            dbInfo.name +
                            '"' +
                            ' has been upgraded from version ' +
                            e.oldVersion +
                            ' to version ' +
                            e.newVersion +
                            ', but the storage "' +
                            dbInfo.storeName +
                            '" already exists.');
                    }
                    else {
                        throw ex;
                    }
                }
            };
        }
        openReq.onerror = function (e) {
            e.preventDefault();
            reject(openReq.error);
        };
        openReq.onsuccess = function () {
            resolve(openReq.result);
            _advanceReadiness(dbInfo);
        };
    });
}
function _getOriginalConnection(dbInfo) {
    return _getConnection(dbInfo, false);
}
function _getUpgradedConnection(dbInfo) {
    return _getConnection(dbInfo, true);
}
function _isUpgradeNeeded(dbInfo, defaultVersion) {
    if (!dbInfo.db) {
        return true;
    }
    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);
    var isDowngrade = dbInfo.version < dbInfo.db.version;
    var isUpgrade = dbInfo.version > dbInfo.db.version;
    if (isDowngrade) {
        // If the version is not the default one
        // then warn for impossible downgrade.
        if (dbInfo.version !== defaultVersion) {
            console.warn('The database "' +
                dbInfo.name +
                '"' +
                " can't be downgraded from version " +
                dbInfo.db.version +
                ' to version ' +
                dbInfo.version +
                '.');
        }
        // Align the versions to prevent errors.
        dbInfo.version = dbInfo.db.version;
    }
    if (isUpgrade || isNewStore) {
        // If the store is new then increment the version (if needed).
        // This will trigger an "upgradeneeded" event which is required
        // for creating a store.
        if (isNewStore) {
            var incVersion = dbInfo.db.version + 1;
            if (incVersion > dbInfo.version) {
                dbInfo.version = incVersion;
            }
        }
        return true;
    }
    return false;
}
// Try to establish a new db connection to replace the
// current one which is broken (i.e. experiencing
// InvalidStateError while creating a transaction).
function _tryReconnect(dbInfo) {
    _deferReadiness(dbInfo);
    var dbContext = dbContexts[dbInfo.name];
    dbInfo.db = null;
    return _getOriginalConnection(dbInfo)
        .then(function (db) {
        dbInfo.db = db;
        if (_isUpgradeNeeded(dbInfo)) {
            // Reopen the database for upgrading.
            return _getUpgradedConnection(dbInfo);
        }
        return db;
    })
        .then(function (db) {
        // store the latest db reference
        // in case the db was upgraded
        dbInfo.db = dbContext.db = db;
    })
        .catch(function (err) {
        _rejectReadiness(dbInfo, err);
        throw err;
    });
}
// FF doesn't like Promises (micro-tasks) and IDDB store operations,
// so we have to do it with callbacks
function createTransaction(dbInfo, mode, callback, retries) {
    if (retries === undefined) {
        retries = 1;
    }
    try {
        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);
        callback(null, tx);
    }
    catch (err) {
        if (retries > 0 &&
            (!dbInfo.db ||
                err.name === 'InvalidStateError' ||
                err.name === 'NotFoundError')) {
            Promise.resolve()
                .then(function () {
                if (!dbInfo.db ||
                    (err.name === 'NotFoundError' &&
                        !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) &&
                        dbInfo.version <= dbInfo.db.version)) {
                    // increase the db version, to create the new ObjectStore
                    if (dbInfo.db) {
                        dbInfo.version = dbInfo.db.version + 1;
                    }
                    // Reopen the database for upgrading.
                    return _getUpgradedConnection(dbInfo);
                }
            })
                .then(function () {
                return _tryReconnect(dbInfo).then(function () {
                    createTransaction(dbInfo, mode, callback, retries - 1);
                });
            })
                .catch(callback);
        }
        callback(err);
    }
}
function normalizeKey(key) {
    // Cast the key to a string, as that's all we can set as a key.
    if (typeof key !== 'string') {
        console.warn(key + " used as a key, but it is not a string.");
        key = String(key);
    }
    return key;
}
function convertDbValue(value) {
    if (value instanceof ArrayBuffer) {
        var uint8Array = new Uint8Array(value);
        // @ts-ignore
        return utf8.decode(String.fromCharCode.apply(null, uint8Array));
    }
    if (typeof value === 'string') {
        return value;
    }
    throw new TypeError('Unknown value format');
}

/**
 * Error thrown from {@link PrivateKeyStorage.save} method when saving
 * a private key with a name that already exists in store.
 */
var PrivateKeyExistsError = /** @class */ (function (_super) {
    __extends(PrivateKeyExistsError, _super);
    function PrivateKeyExistsError(message) {
        if (message === void 0) { message = 'Private key with same name already exists'; }
        return _super.call(this, message, 'PrivateKeyExistsError', PrivateKeyExistsError) || this;
    }
    return PrivateKeyExistsError;
}(VirgilError));

var DEFAULTS$1 = {
    dir: '.virgil_keys',
    name: 'VirgilKeys'
};
/**
 * Class representing a storage container for private key data.
 * Use this class if you need to load the keys stored with
 * version 4.x of this library. For new code, use the
 * {@link PrivateKeyStorage} instead.
 *
 * @deprecated since version 5.0
 */
var KeyStorage = /** @class */ (function () {
    function KeyStorage(config) {
        if (config === void 0) { config = {}; }
        console.log('Warning! `KeyStorage` is deprecated. Use `PrivateKeyStorage` instead.');
        this.adapter = resolveAdapter(config);
    }
    /**
     * Checks whether a private key data with the given name exist in persistent storage.
     * @param {string} name - Name to check.
     * @returns {Promise<boolean>} - True if key data exist, otherwise false.
     */
    KeyStorage.prototype.exists = function (name) {
        validateName(name);
        return this.adapter.exists(name);
    };
    /**
     * Loads the private key data by the given name.
     * @param {string} name - Name of key data to load.
     * @returns {Promise<string | null>} - Private key data as a string,
     * or null if there is no data for the given name.
     */
    KeyStorage.prototype.load = function (name) {
        validateName(name);
        return this.adapter.load(name);
    };
    /**
     * Removes the private key data stored under the given name from persistent storage.
     * @param {string} name - Name of the key data to remove.
     * @returns {Promise<boolean>} - True if the key has been removed, otherwise false.
     */
    KeyStorage.prototype.remove = function (name) {
        validateName(name);
        return this.adapter.remove(name);
    };
    /**
     * Persists the private key data under the given name.
     * @param {string} name - Name of the key data.
     * @param {string} data - The key data.
     * @returns {Promise<void>}
     */
    KeyStorage.prototype.save = function (name, data) {
        validateName(name);
        return this.adapter.store(name, data)
            .catch(function (error) {
            if (error && error.code === 'EEXIST') {
                return Promise.reject(new PrivateKeyExistsError());
            }
            return Promise.reject(error);
        });
    };
    return KeyStorage;
}());
function resolveAdapter(config) {
    if (typeof config === 'string') {
        return new IndexedDbStorageAdapter({ dir: config, name: config });
    }
    var adapter = config.adapter, rest = __rest(config, ["adapter"]);
    if (adapter != null) {
        return adapter;
    }
    return new IndexedDbStorageAdapter(__assign(__assign({}, DEFAULTS$1), rest));
}
function validateName(name) {
    if (!name)
        throw new TypeError('Argument `name` is required.');
}

/**
 * Error thrown when the value loaded from persistent storage cannot be
 * parsed as a {@link IKeyEntry} object.
 */
var InvalidKeyEntryError = /** @class */ (function (_super) {
    __extends(InvalidKeyEntryError, _super);
    function InvalidKeyEntryError(message) {
        if (message === void 0) { message = 'Loaded key entry was in invalid format.'; }
        return _super.call(this, message, 'InvalidKeyEntryError', InvalidKeyEntryError) || this;
    }
    return InvalidKeyEntryError;
}(VirgilError));
/**
 * Error thrown from {@link KeyEntryStorage.save} method when saving a
 * a key entry with the name that already exists in store.
 */
var KeyEntryAlreadyExistsError = /** @class */ (function (_super) {
    __extends(KeyEntryAlreadyExistsError, _super);
    function KeyEntryAlreadyExistsError(name) {
        return _super.call(this, "Key entry " + (name ? 'named ' + name : 'with same name') + "already exists", 'KeyEntryAlreadyExistsError', KeyEntryAlreadyExistsError) || this;
    }
    return KeyEntryAlreadyExistsError;
}(VirgilError));
/**
 * Error thrown from {@link KeyEntryStorage.update} method when updating
 * a key entry that doesn't exist in store.
 */
var KeyEntryDoesNotExistError = /** @class */ (function (_super) {
    __extends(KeyEntryDoesNotExistError, _super);
    function KeyEntryDoesNotExistError(name) {
        return _super.call(this, "Key entry " + (name ? 'named ' + name : 'with the given name') + " does not exist.", 'KeyEntryDoesNotExistError', KeyEntryDoesNotExistError) || this;
    }
    return KeyEntryDoesNotExistError;
}(VirgilError));

var DEFAULTS$2 = {
    dir: '.virgil_key_entries',
    name: 'VirgilKeyEntries'
};
var CREATION_DATE_KEY = 'creationDate';
var MODIFICATION_DATE_KEY = 'modificationDate';
/**
 * Class responsible for persisting private key bytes with optional
 * user-defined metadata.
 */
var KeyEntryStorage = /** @class */ (function () {
    /**
     * Initializes a new instance of `KeyEntryStorage`.
     *
     * @param {IKeyEntryStorageConfig} config - Instance configuration.
     */
    function KeyEntryStorage(config) {
        if (config === void 0) { config = {}; }
        this.adapter = resolveAdapter$1(config);
    }
    /**
     * @inheritDoc
     */
    KeyEntryStorage.prototype.exists = function (name) {
        validateName$1(name);
        return this.adapter.exists(name);
    };
    /**
     * @inheritDoc
     */
    KeyEntryStorage.prototype.load = function (name) {
        validateName$1(name);
        return this.adapter.load(name).then(function (data) {
            if (data == null) {
                return null;
            }
            return deserializeKeyEntry(data);
        });
    };
    /**
     * @inheritDoc
     */
    KeyEntryStorage.prototype.remove = function (name) {
        validateName$1(name);
        return this.adapter.remove(name);
    };
    /**
     * @inheritDoc
     */
    KeyEntryStorage.prototype.save = function (_a) {
        var name = _a.name, value = _a.value, meta = _a.meta;
        validateNameProperty(name);
        validateValueProperty(value);
        var keyEntry = {
            name: name,
            value: value,
            meta: meta,
            creationDate: new Date(),
            modificationDate: new Date()
        };
        return this.adapter.store(name, serializeKeyEntry(keyEntry))
            .then(function () { return keyEntry; })
            .catch(function (error) {
            if (error && error.name === 'StorageEntryAlreadyExistsError') {
                throw new KeyEntryAlreadyExistsError(name);
            }
            throw error;
        });
    };
    /**
     * @inheritDoc
     */
    KeyEntryStorage.prototype.list = function () {
        return this.adapter.list()
            .then(function (entries) { return entries.map(function (entry) { return deserializeKeyEntry(entry); }); });
    };
    /**
     * @inheritDoc
     */
    KeyEntryStorage.prototype.update = function (_a) {
        var _this = this;
        var name = _a.name, value = _a.value, meta = _a.meta;
        validateNameProperty(name);
        if (!(value || meta)) {
            throw new TypeError('Invalid argument. Either `value` or `meta` property is required.');
        }
        return this.adapter.load(name)
            .then(function (data) {
            if (data === null) {
                throw new KeyEntryDoesNotExistError(name);
            }
            var entry = deserializeKeyEntry(data);
            var updatedEntry = Object.assign(entry, {
                value: value || entry.value,
                meta: meta || entry.meta,
                modificationDate: new Date()
            });
            return _this.adapter.update(name, serializeKeyEntry(updatedEntry))
                .then(function () { return updatedEntry; });
        });
    };
    /**
     * @inheritDoc
     */
    KeyEntryStorage.prototype.clear = function () {
        return this.adapter.clear();
    };
    return KeyEntryStorage;
}());
function serializeKeyEntry(keyEntry) {
    return JSON.stringify(keyEntry);
}
function deserializeKeyEntry(data) {
    try {
        return JSON.parse(data, function (key, value) {
            if (key === CREATION_DATE_KEY || key === MODIFICATION_DATE_KEY) {
                return new Date(value);
            }
            return value;
        });
    }
    catch (error) {
        throw new InvalidKeyEntryError();
    }
}
function resolveAdapter$1(config) {
    if (typeof config === 'string') {
        return new IndexedDbStorageAdapter({ dir: config, name: config });
    }
    var adapter = config.adapter, rest = __rest(config, ["adapter"]);
    if (adapter != null) {
        return adapter;
    }
    return new IndexedDbStorageAdapter(__assign(__assign({}, DEFAULTS$2), rest));
}
var requiredArg = function (name) { return function (value) {
    if (!value)
        throw new TypeError("Argument '" + name + "' is required.");
}; };
var requiredProp = function (name) { return function (value) {
    if (!value)
        throw new TypeError("Invalid argument. Property " + name + " is required");
}; };
var validateName$1 = requiredArg('name');
var validateNameProperty = requiredProp('name');
var validateValueProperty = requiredProp('value');

/**
 * Class responsible for storage of private keys.
 */
var PrivateKeyStorage = /** @class */ (function () {
    /**
     * Initializes a new instance of `PrivateKeyStorage`.
     * @param {IPrivateKeyExporter} privateKeyExporter - Object responsible for
     * exporting private key bytes from `IPrivateKey` objects and importing
     * private key bytes into `IPrivateKey` objects.
     * @param {IKeyEntryStorage} keyEntryStorage - Object responsible for
     * persistence of private keys data.
     */
    function PrivateKeyStorage(privateKeyExporter, keyEntryStorage) {
        if (keyEntryStorage === void 0) { keyEntryStorage = new KeyEntryStorage(); }
        this.privateKeyExporter = privateKeyExporter;
        this.keyEntryStorage = keyEntryStorage;
    }
    /**
     * Persists the given `privateKey` and `meta` under the given `name`.
     * If an entry with the same name already exists rejects the returned
     * Promise with {@link PrivateKeyExistsError} error.
     *
     * @param {string} name - Name of the private key.
     * @param {IPrivateKey} privateKey - The private key object.
     * @param {Object<string, string>} [meta] - Optional metadata to store with the key.
     *
     * @returns {Promise<void>}
     */
    PrivateKeyStorage.prototype.store = function (name, privateKey, meta) {
        return __awaiter(this, void 0, void 0, function () {
            var privateKeyData, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        privateKeyData = this.privateKeyExporter.exportPrivateKey(privateKey);
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.keyEntryStorage.save({ name: name, value: privateKeyData.toString('base64'), meta: meta })];
                    case 2:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        if (error_1 && error_1.name === 'KeyEntryAlreadyExistsError') {
                            throw new PrivateKeyExistsError("Private key with the name " + name + " already exists.");
                        }
                        throw error_1;
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Retrieves the private key with the given `name` from persistent storage.
     * If private with the given name does not exist, resolves the returned
     * Promise with `null`.
     *
     * @param {string} name - Name of the private key to load.
     * @returns {Promise<IPrivateKeyEntry|null>}
     */
    PrivateKeyStorage.prototype.load = function (name) {
        return __awaiter(this, void 0, void 0, function () {
            var keyEntry, privateKey;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.keyEntryStorage.load(name)];
                    case 1:
                        keyEntry = _a.sent();
                        if (keyEntry === null) {
                            return [2 /*return*/, null];
                        }
                        privateKey = this.privateKeyExporter.importPrivateKey(keyEntry.value);
                        return [2 /*return*/, {
                                privateKey: privateKey,
                                meta: keyEntry.meta
                            }];
                }
            });
        });
    };
    /**
     * Removes the private key entry with the given `name` from persistent
     * storage.
     *
     * @param {string} name - Name of the private key to remove.
     * @returns {Promise<void>}
     */
    PrivateKeyStorage.prototype.delete = function (name) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.keyEntryStorage.remove(name)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return PrivateKeyStorage;
}());

exports.CachingJwtProvider = CachingJwtProvider;
exports.CallbackJwtProvider = CallbackJwtProvider;
exports.CardManager = CardManager;
exports.ConstAccessTokenProvider = ConstAccessTokenProvider;
exports.DefaultStorageAdapter = IndexedDbStorageAdapter;
exports.GeneratorJwtProvider = GeneratorJwtProvider;
exports.InvalidKeyEntryError = InvalidKeyEntryError;
exports.Jwt = Jwt;
exports.JwtGenerator = JwtGenerator;
exports.JwtVerifier = JwtVerifier;
exports.KeyEntryAlreadyExistsError = KeyEntryAlreadyExistsError;
exports.KeyEntryDoesNotExistError = KeyEntryDoesNotExistError;
exports.KeyEntryStorage = KeyEntryStorage;
exports.KeyStorage = KeyStorage;
exports.ModelSigner = ModelSigner;
exports.PrivateKeyStorage = PrivateKeyStorage;
exports.RawSignedModel = RawSignedModel;
exports.StorageEntryAlreadyExistsError = StorageEntryAlreadyExistsError;
exports.VirgilAgent = VirgilAgent;
exports.VirgilCardVerifier = VirgilCardVerifier;
